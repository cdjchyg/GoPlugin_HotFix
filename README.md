

基于go的Plugin实现热更新业务逻辑

    1. 数据放在非热更新部分
    2. 逻辑放在热更新部分
    3. 可以运行期间动态替换热更新部分

在Server/main.go中演示了 类似热更新的 过程

1. 初步测试调用Plugin方法耗时相对于本地方法底10倍左右，采用该方案需要严格控制Plugin方法调用，尽量在自己域内完成
2. 架构的需要做限制，避免业务开发是在Plugin层保存状态
3. 热更新无法修改主程序的数据结构，否则可能导致热更新和非热更新部分数据结构不一致带来crash

待验证问题：
    plugin.open底层采用了so path的方式缓存了加载，如果再次加载相同会直接返回之前版本，也没有提供卸载机制；只有尝试so path加入版本号控制采用不同的path，加載新版本的so，可以实现热更新的效果、不确定大规模使用不卸载老的so会不会有什么副作用
